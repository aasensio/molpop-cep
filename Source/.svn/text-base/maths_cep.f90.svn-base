module maths_cep
implicit none
contains

! *********************************************************
! *********************************************************
! MATHEMATICAL ROUTINES
! *********************************************************
! *********************************************************

! ---------------------------------------------------------
! Read some lines from a file
! ---------------------------------------------------------
	subroutine lb(unit,nlines)
   integer :: unit, nlines, i
   	do i = 1, nlines
      	read(unit,*)
      enddo
   end subroutine lb

! ---------------------------------------------------------
! Given xa(:) and ya(:) which tabulate a function, returns the interpolation using
! linear interpolation of vector x(:) in y(:)
! ---------------------------------------------------------
   subroutine lin_interpol(xa,ya,x,y)
   real*8, INTENT(IN) :: xa(:), ya(:), x(:)
   real*8, INTENT(INOUT) :: y(:)
   integer :: i, n, na
   integer :: locat(1), loc

   	n = size(x)
   	na = size(xa)

   	do i = 1, n
			loc = 1
			do while (xa(loc) < x(i))
				loc = loc + 1
			enddo
			if (loc > na) then				
				loc = na				
			endif
   		if (loc == 1) then
				y(i) = ya(loc)   		
   		else
				y(i) = (ya(loc)-ya(loc-1))/(xa(loc)-xa(loc-1)) * (x(i)-xa(loc-1)) + ya(loc-1)
   		endif
   	enddo

   end subroutine lin_interpol
	
! ---------------------------------------------------------
! LU decomposition of a matrix
!  INPUT:
!		- a is the matrix to decompose
!		
!  OUTPUT:
!		- a is the LU decomposition of a
!		- indx is a vector that records the row permutation effected by the partial pivoting
!		- d takes values +1/-1 depending on whether the number of row interchanges was odd or even
! ---------------------------------------------------------
	subroutine ludcmp(a,indx,d)
	integer, INTENT(INOUT) :: indx(:)
	real(kind=8), INTENT(INOUT) :: a(:,:), d
	real(kind=8), parameter :: TINY = 1.d-20
	integer :: i, imax, j, k, n
	real(kind=8) :: aamax, dum, sum, vv(size(a,1))
		d = 1.d0
		n = size(a,1)
		
		do i = 1, n
			aamax = 0.d0	
			aamax = maxval(dabs(a(i,:)))
			if (aamax == 0.d0) then
				print *, 'Singular matrix in LU decomposition'
				stop
			endif
			vv(i) = 1.d0 / aamax
		enddo
		
		do j = 1, n
			do i = 1, j-1
				sum = a(i,j)
				do k = 1, i-1
					sum = sum - a(i,k) * a(k,j)
				enddo
				a(i,j) = sum
			enddo
			aamax = 0.d0
			do i = j, n
				sum = a(i,j)
				do k = 1, j-1
					sum = sum - a(i,k) * a(k,j)
				enddo
				a(i,j) = sum
				dum = vv(i) * dabs(sum)
				if (dum >= aamax) then
					imax = i
					aamax = dum
				endif				
			enddo
			if (j /= imax) then
				do k = 1, n
					dum = a(imax,k)
					a(imax,k) = a(j,k)
					a(j,k) = dum
				enddo
				d = -d
				vv(imax) = vv(j)
			endif
			indx(j) = imax
			if (a(j,j) == 0.d0) a(j,j) = TINY
			if (j /= n) then
				dum = 1.d0 / a(j,j)
				do i = j+1, n
					a(i,j) = a(i,j) * dum
				enddo
			endif
		enddo
	
	end subroutine ludcmp

! ---------------------------------------------------------
! Solves the set of equations AX=b where A is the LU decomposition of a matrix
!  INPUT:
!		- a is the LU decomposition of the system matrix
!		- b is the right hand side vector of the system
! 		- indx is the vector returned by ludcmp
!  OUTPUT:
!		- b is the solution of the system
! ---------------------------------------------------------
	subroutine lubksb(a,indx,b)
	real(kind=8), INTENT(IN) :: a(:,:)
	real(kind=8), INTENT(INOUT) :: b(:)
	integer, INTENT(IN) :: indx(:)
	integer :: i, ii, n, j, ll
	real(kind=8) :: sum
		n = size(a,1)
		ii = 0
		do i = 1, n
			ll = indx(i)
			sum = b(ll)
			b(ll) = b(i)
			if (ii /= 0) then
				do j = ii, i-1
					sum = sum - a(i,j) * b(j)
				enddo
			else if (sum /= 0.d0) then
				ii = i
			endif
			b(i) = sum
		enddo
		do i = n, 1, -1
			sum = b(i)
			do j = i+1, n
				sum = sum - a(i,j) * b(j)
			enddo
			b(i) = sum / a(i,i)
		enddo
	end subroutine lubksb
	
! ---------------------------------------------------------
! Resuelve un sistema de ecuaciones
! ---------------------------------------------------------
!     SOLUTION OF A SYSTEM OF LINEAR EQUATIONS -- A*X = X
!
!     INPUT FOR LUSLV
!     A        -LEFT HAND SIDE
!     X        -RIGHT HAND SIDE
!     N        -ORDER OF THE SYSTEM
!     NR       -ACTUAL FIRST DIMENSION OF A
!
!     OUTPUT FOR LUSLV
!     A        -LU FACTORIZATION OF ORIGINAL A
!     X        -SOLUTION OF THE LINEAR EQUATIONS
!
!     ONCE LUSLV HAS BEEN CALLED, OTHER SYSTEMS WITH THE SAME LEFT HAND
!     SIDE BUT DIFFERENT RIGHT HAND SIDES MAY BE EFFICIENTLY SOLVED BY
!     USING RESLV.
!
!     INPUT FOR RESLV
!     A        -LU FACTORIZATION OF LEFT HAND SIDE, PRODUCED BY A PREVIOUS
!              -CALL TO LUSLV
!     X        -RIGHT HAND SIDE
!     N        -ORDER OF THE SYSTEM, MUST BE THE SAME AS WHEN LUSLV WAS CALLED
!     NR       -ACTUAL FIRST DIMENSION OF A
!
!     OUTPUT FOR RESLV
!     X        -SOLUTION OF THE LINEAR EQUATIONS
	SUBROUTINE LUSLV(A,X,N,NR)
	
      IMPLICIT real(kind=8)(A-H,O-Z)
		integer :: n, nr
      DIMENSION A(NR,*),X(*),D(100)
      INTEGER R,P(100), i, k, mr1, j, itemp, jp1
      COMMON /LUCOMM/ D,P
      DO 7 R = 1, N
         DO 1 K = 1, N
            D(K) = A(K,R)
    1    CONTINUE
         MR1 = R - 1
         IF(MR1.LT.1) GO TO 4
         DO 3 J = 1, MR1
            ITEMP = P(J)
            A(J,R) = D(ITEMP)
            D(ITEMP) = D(J)
            JP1 = J + 1
            DO 2 I = JP1, N
               D(I) = D(I) - A(I,J)*A(J,R)
    2       CONTINUE
    3    CONTINUE
    4    DMX = ABS(D(R))
         P(R) = R
         DO 5 I = R, N
            IF(DMX.GT.ABS(D(I))) GO TO 5
            DMX = ABS(D(I))
            P(R) = I
    5    CONTINUE
         ITEMP = P(R)
         A(R,R) = 1.0/D(ITEMP)
         D(ITEMP) = D(R)
         MR1 = R + 1
         IF(MR1.GT.N) GO TO 8
         DO 6 I = MR1, N
            A(I,R) = D(I)*A(R,R)
    6    CONTINUE
    7 CONTINUE
    8 CALL RESLV(A,X,N,NR)
      
      END subroutine luslv
		
		
      SUBROUTINE RESLV(A,X,N,NR)
		
      IMPLICIT real(kind=8)(A-H,O-Z)
		integer :: n, nr
      INTEGER P(100), i, ip1, j, k, kp1, itemp
      real(kind=8) D(100),A(NR,*),X(*)
      COMMON /LUCOMM/ D,P
      DO 9 I = 1, N
         D(I) = X(I)
    9 CONTINUE
      DO 11 I = 1, N
         ITEMP = P(I)
         X(I) = D(ITEMP)
         D(ITEMP) = D(I)
         IP1 = I + 1
         IF(IP1.GT.N) GO TO 12
         DO 10 J = IP1, N
            D(J) = D(J) - A(J,I)*X(I)
   10    CONTINUE
   11 CONTINUE
   12 K = N + 1
      DO 15 I = 1, N
         K = K - 1
         SUM = 0.0
         KP1 = K + 1
         IF(KP1.GT.N) GO TO 14
         DO 13 J = KP1, N
            SUM = SUM + A(K,J)*X(J)
   13    CONTINUE
   14    X(K) = A(K,K)*(X(K)-SUM)
   15 CONTINUE
      END subroutine reslv


      

! ---------------------------------------------------------
! Solve a linear system of equations
! ---------------------------------------------------------	
	subroutine llslv(S,X,N,NR)
	integer, INTENT(IN) :: n, nr
	real(kind=8), INTENT(INOUT) :: S(nr,nr), x(nr)
	real(kind=8) :: sum
	integer :: i, j, k
	
	do i = 1, n
		do j = 1, i
			sum = s(i,j)
			do k = 1, j-1
				sum = sum - S(i,k) * S(j,k)
			enddo !k
			if (j < i) then
				s(i,j) = sum / S(j,j)
			else
				S(i,j) = dsqrt(dabs(sum))
			endif
		enddo !j
	enddo !i
	
	entry llreslv(S,X,N,NR)
	
	do i = 1, n
		sum = x(i)
		do j = 1, i-1
			sum = sum - S(i,j)*x(j)
		enddo !j
		x(i) = sum / S(i,i)
	enddo !i
	do i = n, 1, -1
		sum = x(i)
		do j = n, i+1, -1
			sum = sum - S(j,i)*x(j)
		enddo !j
		x(i) = sum / S(i,i)
	enddo !i
	
	end subroutine llslv
	      
! ---------------------------------------------------------
! Return the exponential integral En(x)
! ---------------------------------------------------------      
      FUNCTION expint(n,x)
      INTEGER n,MAXIT
      REAL(kind=8) expint,x,EPS,FPMIN,EULER
      PARAMETER (MAXIT=100,EPS=1.e-7,FPMIN=1.e-30,EULER=.5772156649)
      INTEGER i,ii,nm1
      REAL(kind=8) a,b,c,d,del,fact,h,psi
      nm1=n-1
      if(n.lt.0.or.x.lt.0..or.(x.eq.0..and.(n.eq.0.or.n.eq.1)))then
        print *, n, x
        print *, 'bad arguments in expint'
        stop
      else if(n.eq.0)then
        expint=exp(-x)/x
      else if(x.eq.0.)then
        expint=1./nm1
      else if(x.gt.1.)then
        b=x+n
        c=1./FPMIN
        d=1./b
        h=d
        do 11 i=1,MAXIT
          a=-i*(nm1+i)
          b=b+2.
          d=1./(a*d+b)
          c=b+a/c
          del=c*d
          h=h*del
          if(abs(del-1.).lt.EPS)then
            expint=h*exp(-x)
            return
          endif
11      continue
        print *, 'continued fraction failed in expint'
        stop
      else
        if(nm1.ne.0)then
          expint=1./nm1
        else
          expint=-log(x)-EULER
        endif
        fact=1.
        do 13 i=1,MAXIT
          fact=-fact*x/i
          if(i.ne.nm1)then
            del=-fact/(i-nm1)
          else
            psi=-EULER
            do 12 ii=1,nm1
              psi=psi+1./ii
12          continue
            del=fact*(-log(x)+psi)
          endif
          expint=expint+del
          if(abs(del).lt.abs(expint)*EPS) return
13      continue
        print *, 'series failed in expint'
        stop
      endif
      return
      END function expint


! ---------------------------------------------------------
! Given x(:) and y(:) which tabulate a function and the derivative at the boundary points
! this function returns the second derivative of the spline at each point
! ---------------------------------------------------------
		subroutine splin1(x,y,yp1,ypn,y2)
		real(kind=8), INTENT(IN) :: x(:), y(:), yp1, ypn
		real(kind=8), INTENT(INOUT) :: y2(size(x))
		integer :: n, i, k
		real(kind=8) :: p, qn, sig, un, u(size(x))

			n = size(x)
			
			if (yp1 > .99d30) then
				y2(1) = 0.d0
				u(1) = 0.d0
			else
				y2(1) = -0.5d0
				u(1) = (3.d0/(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
			endif

			do i = 2, n-1
				sig = (x(i)-x(i-1))/(x(i+1)-x(i-1))				
				p = sig * y2(i-1)+2.d0
				y2(i) = (sig-1.d0)/p
				u(i) = (6.d0*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))/&
					(x(i+1)-x(i-1))-sig*u(i-1))/p
			enddo
			if (ypn > .99d30) then
				qn = 0.d0
				un = 0.d0
			else
				qn = 0.5d0
				un = (3.d0/(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
			endif
			
			y2(n) = (un-qn*u(n-1))/(qn*y2(n-1)+1.d0)

			do k = n-1, 1, -1
				y2(k) = y2(k)*y2(k+1)+u(k)
			enddo

		end subroutine splin1

! ---------------------------------------------------------
! Given xa(:) and ya(:) which tabulate a function, returns the interpolation using
! splines of vector x(:) in y(:)
! ---------------------------------------------------------
		subroutine spline(xa,ya,y2a,x,y)
		real(kind=8), INTENT(INOUT) :: y(:)
		real(kind=8), INTENT(IN) :: xa(:), ya(:), x(:)
		real(kind=8) :: y2a(:)
		integer :: n_x, n, i, k, khi, klo
		real(kind=8) :: a, b, h, extrap
			
			n = size(xa)
			n_x = size(x)
			!call splin1(xa,ya,1.d30,1.d30,y2a)						

			do i = 1, n_x					

! Downward extrapolation 
				if (x(i) < xa(1)) then
!					y(i) = ya(1)
					y(i) = ya(1) + (ya(1)-ya(2))/(xa(1)-xa(2)) * (xa(1) - x(i))
				else 

! Upward extrapolation
				if (x(i) > xa(n)) then
!					y(i) = ya(n)
					y(i) = ya(n) + (ya(n)-ya(n-1)) / (xa(n)-xa(n-1)) * (x(i) - xa(n))
				else
! In range
						klo = 1
						khi = n
1						if(khi-klo > 1) then
							k = (khi+klo)/2
							if (xa(k) > x(i)) then
								khi = k
							else
								klo = k
							endif					
							go to 1
						endif

						h = xa(khi)-xa(klo)

						if (h == 0.d0) then
							print *, 'bad xa input in spline'
							stop
						endif
						a = (xa(khi)-x(i))/h
						b = (x(i)-xa(klo))/h

						y(i) = a*ya(klo)+b*ya(khi)+((a**3.d0-a)*y2a(klo)+&
							(b**3.d0-b)*y2a(khi))*(h**2.d0)/6.d0		
					endif
				endif
			enddo

		end subroutine spline
		
!-----------------------------------------------------------------
! Returns the weights (w) and the abscissas (x) for a Gaussian integration using the 
! Gauss-Legendre formula, using n points
!-----------------------------------------------------------------
	subroutine gauleg(x1,x2,x,w,n)
	integer, INTENT(IN) :: n
	real(kind=8), INTENT(IN) :: x1,x2
	real(kind=8), INTENT(INOUT) :: x(n),w(n)
	real(kind=8), parameter :: eps = 3.d-14
	integer :: i,j,m
	real(kind=8) :: p1,p2,p3,pp,xl,xm,z,z1
      
	m=(n+1)/2
   xm=0.5d0*(x2+x1)
   xl=0.5d0*(x2-x1)
   do i=1,m
   	z=dcos(3.141592654d0*(i-.25d0)/(n+.5d0))
1  	continue
   	p1=1.d0
   	p2=0.d0
   	do j=1,n
   		p3=p2
      	p2=p1
      	p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j
		enddo
   	pp=n*(z*p1-p2)/(z*z-1.d0)
   	z1=z
   	z=z1-p1/pp
  		if(abs(z-z1).gt.EPS)goto 1
   	x(i)=xm-xl*z
   	x(n+1-i)=xm+xl*z
   	w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)
   	w(n+1-i)=w(i)
	enddo
	
	end subroutine gauleg

end module maths_cep
